\documentclass[oneside,a4paper,12pt]{book}
%\pagestyle{headings}
\frontmatter
\input{preamble}

% A B S T R A C T
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\chapter*{\centering Abstract}
\begin{quotation}
\noindent
A previous study found out that \npe is the most frequently occurring and difficult to debug exception in Java projects. \todo{Nevena: In the introduction, when this is elaborated, make sure there are some references to support this claim.} It is difficult to debug because a developer is only provided with a stack trace to the line of code where the exception was thrown. This only gives insight into the effect of the fault but not into its cause.

The aim of the project is to provide the developer with an additional stack trace of where the variable that caused the \npe was actually set to null. We attempt to achieve this goal by instrumenting java source code, while striving for a minimal execution overhead.

By tracking the null assignments through static analysis and by instrumenting the bytecode we can achieve a more efficient debugging process after an occurrence of a \npe.
\end{quotation}
\clearpage


% C O N T E N T S
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\tableofcontents

\mainmatter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                            Introduction                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}
\label{ch:introduction}

\Npe is a commonly occurring \rte in object-oriented languages. \todo{Add some references}\lt{falls noch zeit Ã¼brig bleibt, werde ich noch mehr danach suchen. bis jetzt noch nichts gefunden.}In most OOP languages there is a special \textbf{null} value that is assigned to references in order to indicate that the reference does not refer to an object. A \npe is caused by invoking a method or accessing a field through a null value reference, \ie a reference with the null value.

Previous research has found that 35\% of conditional checks in Java projects are null checks. This reduces the readability of source code and has a negative impact on performance~\cite{Osma16a}. It is also considered the number one error Java programmers make\footnote{\url{http://www.webcitation.org/6lNPzbIyy}}.

To better understand occurrences of \npes we present two different example situations in which a \npe can be thrown.

\renewcommand\lstlistingname{Code}
\begin{Java}[caption={\Npe example (I). The null assignment takes place at line 5 and the \npe is thrown in line 7.}, label={code:npeExampleMethodReceiver}]
public void drop(...) {
	..
	try {
		..
		DNDFigures (@\textbf{ff}@) = DNDHelper.processReceivedData(...);
		..
		Point theO = (@\textbf{ff}@).getOrigin();
		..
	}
	catch (NullPointerException npe) {
		npe.printStackTrace();
		..
	}
	..
}
\end{Java}

Assume that in the example shown in \coderef{npeExampleMethodReceiver}\footnote{\label{codeTaken1}Code snippet is a modified version of code taken from JHotDraw project: \url{http://www.jhotdraw.org/}} the variable \code{ff} at line 5 is assigned the null value as the result of assigning the return value of the method \code{DNDHelper.processReceivedData(...)} to the variable. This means that the same variable \code{ff} is null at line 7 and when a method is invoked on this object a \npe is thrown. Because the \npe occurred in the \code{try\{\}} block the following \code{catch\{\}} block will handle the exception by printing the stack trace. The stack trace takes the developer to line 7 where the exception was thrown but not to the real culprit which is the assignment at line 5.

\renewcommand\lstlistingname{Code}
\begin{Java}[caption={\Npe example (II). The null assignment takes place at line 14 and the \npe is thrown in line 24.}, label={code:npeExampleFieldAccess}]
public class DrawApplication {
	..
	private IconkitManager (@\textbf{fManager}@);

	protected void open(...) {
		..
		createIconkit();
		..
		setTool(...);
		..
	}

	protected Iconkit createIconkit() {
		(@\textbf{fManager}@) = getIconkitManager();
		..
	}

	protected getIconkitManager() {
		return null;
	}

	public void setTool(...) {
		..
		(@\textbf{fManager}@).getComponent();
		..
	}
	..
}
\end{Java}

A more complicated way a \npe can be triggered is when it involves variables with larger scopes such as class members. \coderef{npeExampleFieldAccess}\textsuperscript{\ref{codeTaken1}} shows such a situation. This code snippet defines the class named \code{DrawApplication} which has the field \code{fManager} (declared at line 3). This class contains four relevant methods: \code{open(...)}, \code{createIconkit()}, \code{getIconkitManager()} and \code{setTool(...)}.

The \code{open(...)} method invokes the methods \code{createIconkit()} at line 7 and \code{setTool(...)} at line 9. By calling \code{createIconkit()} at line 7 the field \code{fManager} is assigned null. The field is assigned null by performing the method \code{getIconkitManager()} at line 14, which just returns the null value at line 19.

Afterwards, when the method \code{open(...)} calls \code{setTool()}, the attempt to call the method \code{getComponent()} on field \code{fManager} at line 24 causes the \npe. The resulting \npe stack trace is shown in \stacktraceref{stackTrace}:

\begin{figure}[H]
\renewcommand\figurename{Stack trace}
	\begin{boxedminipage}{\textwidth}
		\color{cadmiumred}
		Exception in thread "main" \textcolor{blue}{java.lang.NullPointerException}\newline
		\tab at org.jhotdraw.application.DrawApplication.setTool(\textcolor{blue}{DrawApplication.java:24})\newline
		\tab at org.jhotdraw.application.DrawApplication.open(\textcolor{blue}{DrawApplication.java:9})\newline
	 \tab ...
	\end{boxedminipage}
	\caption{Common stack trace of a \npe.}
	\label{stacktrace:stackTrace}
\end{figure}

In \stacktraceref{stackTrace} we can see that the stack trace points only to the line 24, where \npe occured, and it does not track to the location where the variable is assigned the null value. We call this location the root of an exception. That means the Java developer has to debug their way to the exception root.

At this point we introduce our project named \textit{\textbf{NullSpy}} which supports the developers in situations discussed previously. The main goal of NullSpy is to take a step towards minimizing the time spent debugging \npes. The intention behind NullSpy is to, once an unhandled \npe has occurred, present the developer the exact location of the null assignment next to the ordinary stack trace, as shown in \stacktraceref{stackTrace2}.

\begin{figure}[H]
\renewcommand\figurename{Stack trace}
	\begin{boxedminipage}{\textwidth}
		\color{cadmiumred}
		Field this.fManager at line 14 is null: (\textcolor{blue}{DrawApplication.java: 14})\\
		Exception in thread "main" \textcolor{blue}{java.lang.NullPointerException}\\
		\tab at org.jhotdraw.application.DrawApplication.setTool(\textcolor{blue}{DrawApplication.java:24})\\
		\tab at org.jhotdraw.application.DrawApplication.open(\textcolor{blue}{DrawApplication.java:9})\\
	 \tab ...
	\end{boxedminipage}
	\caption{Stack trace of a \npe with NullSpy.}
	\label{stacktrace:stackTrace2}
\end{figure}

In this thesis we explain how the goal mentioned above is achieved and we also discuss the challenges, the limitations and performance impact of the approach.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                        Technical Background                         %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter {Technical Background}
\label{ch:technicalBackground}

This chapter provides a short overview of technologies used in the implementation of NullSpy.

%===============================================================================
\section{Bytecode}
\label{sec:bytecode}

The backbone of NullSpy is analysis and modification of Java bytecode. Java bytecode is an abstract machine language that the stack-based Java virtual machine (JVM) can understand and execute. A JVM keeps an operand stack which is modified every time the JVM executes an instruction. The instruction is represented by an opcode (operation code) which also has a string representation.

Since bytecode plays an important role in our project, we will describe the Java bytecode and explain some terms we often use in this thesis. 

\renewcommand\lstlistingname{Code}
\begin{Java}[caption={The use of the \textit{Hello World} example to explain bytecode.}, label={code:helloWorld}][H]
public class HelloWorld {
	private String hello = "Hello World!";

	public void say() {
		String result = hello;
		System.out.println(result);
	}
}
\end{Java}

\renewcommand\lstlistingname{Bytecode}
\begin{JVMIS}[numbers=left, caption={Bytecode of \coderef{helloWorld}.}, label={bytecode:helloWorld}, breaklines=true][H]
public void say();
	 0  aload_0 [this]
	 1  getfield HelloWorld.hello : java.lang.String [14]
	 4  astore_1 [result]
	 5  getstatic java.lang.System.out : java.io.PrintStream [21]
	 8  aload_1 [result]
	 9  invokevirtual java.io.PrintStream.println(java.lang.String) : void [27]
	12  return
		Line numbers:
			[pc: 0, line: 5]
			[pc: 5, line: 6]
			[pc: 12, line: 7]
		Local variable table:
			[pc: 0, pc: 13] local: this index: 0 type: HelloWorld
			[pc: 5, pc: 13] local: result index: 1 type: java.lang.String
\end{JVMIS}

We start with an easy \textit{HelloWorld} source code example (\coderef{helloWorld}). The code snippet in the example \coderef{helloWorld} contains the definition of the class \code{HelloWorld} with an instance field named \code{hello} and method \code{say()} which prints the value of the field. The bytecode of the method \code{say()} is represented in the \bytecoderef{helloWorld}. We omit the bytecode of the class and field definition since it is not relevant for our example.

The green words in \bytecoderef{helloWorld} are the string representations of Java bytecode instructions. We will also use the term \textbf{opcode} when referring to individual instructions. Multiple opcode instructions are referred to as \textbf{bytecode}.

On the left-side of these instructions we see the \textbf{program counter} (pc) which is a processor register that contains the address (location) of the instruction being executed at the current time. It is also called an \textbf{instruction pointer}.
%We use these program counters, or pc-s also as an index in the bytecode. 

The instructions from pc 0 to pc 4 (lines 2-4 in \bytecoderef{helloWorld}) represents the source code at line 5 in \coderef{helloWorld}. Therefore we use the term \textbf{pc-interval} to describe a set of instructions that represents a Java expression. This term will play an important role further in the thesis. We use the syntax \textbf{``<,>''} to represent an pc-interval, \eg just mentioned pc-interval <0,4> represents the source code at line 5 in \coderef{helloWorld}. The first number indicates where the pc-interval starts, thus we name it \textbf{start-pc} and the latter one where it ends, hence the name \textbf{end-pc}, both inclusive. In the same example, the pc-interval of the local variable \code{result} is <4,4>.

If the opcode represents a variable, on its right side we can see the information about the name and type of the variable, \eg line 3. 
In case of an invocation opcode, it shows the behavior/method name, the parameter types and the return type, \eg line 7. 

Each method bytecode representation holds a \textbf{line number table} and a \textbf{local variable table} which are listed underneath the instructions of the method (lines 9-15 in \bytecoderef{helloWorld}). 

The line number table\footnote{In the jargon of Javasist, this is also called the line number attribute.} maps source code line of the method with the pc which indicates the beginning of the bytecode to the corresponding source code line. The line number table in \bytecoderef{helloWorld} is represented between the lines 9 and 12: source code line 5 starts with the pc 0 (as shown on line 10), source code line 6 starts with the pc 5 (in line 11) \etc This mapping does not apply to cases where a statement is separated into multiple lines.

If we look back, to the \stacktraceref{stackTrace}, we see that the stack trace provides us with a part of the call-chain that led to the \npe. This includes the line numbers in the source code where the invocations happened. The information the line number table holds is used to recover the information about the actual point in the code where the null was assigned to a reference. 
%In \secref{lowLevelOverview} we will discuss how this is done.

\renewcommand\lstlistingname{Code}
\begin{Java}[caption={\chk{The source code for which the local variable table of its bytecode contains two entries with the same slot.}}, label={code:localVarTableDuplicatedSlot1SourceCode}]
private void loadDrawing(String filename) {
		try {
			URL url = new URL(getCodeBase(), filename);
			InputStream stream = url.openStream();
			StorableInput reader = new StorableInput(stream);
			fDrawing = (Drawing)reader.readStorable();
		}
		catch (IOException e) {
			fDrawing = createDrawing();
			System.err.println("Error when Loading: " + e);
			showStatus("Error when Loading: " + e);
		}
	}
\end{Java}

\renewcommand\lstlistingname{Bytecode}
\begin{JVMIS}[numbers=left, caption={Bytecode of \coderef{localVarTableDuplicatedSlot1SourceCode}.\chk{please check if this bytecode is ok.}}, label={bytecode:bytecodeOfLocalVarTableDuplicatedSlot1SourceCode}, breaklines=true]
private void loadDrawing(java.lang.String filename);
	0  new java.net.URL [98]
	...
	13  aload_2 [url]
	...
	40  goto 94
	...
	94  return
\end{JVMIS} 

\renewcommand\lstlistingname{Bytecode}
\begin{JVMIS}[numbers=left, caption={Local variable table of \bytecoderef{bytecodeOfLocalVarTableDuplicatedSlot1SourceCode} entries with same slot 2 (line 4 and 7).}, label={bytecode:localVarTableDuplicatedSlot1}, breaklines=true]
Local variable table:
 [pc: 0, pc: 95] local: this index: 0 type: org.jhotdraw.samples.javadraw.JavaDrawViewer
 [pc: 0, pc: 95] local: filename index: 1 type: java.lang.String
 (@\textbf{[pc: 13, pc: 40] local: url index: 2 type: java.net.URL}@)
 [pc: 18, pc: 40] local: stream index: 3 type: java.io.InputStream
 [pc: 28, pc: 40] local: reader index: 4 type: org.jhotdraw.util.StorableInput
 (@\textbf{[pc: 44, pc: 94] local: e index: 2 type: java.io.IOException}@)
\end{JVMIS}

As mentioned before, the bytecode of each method also holds a local variable table which is an array of the information about local variables (lines 13-15 in \bytecoderef{helloWorld}). This table has the information about the \textit{this} reference (if the method is an instance method or a constructor), about method parameters and method local variables, respectively. Example of the \textit{this} reference representation can be seen in the line 14. Each line of this table represents one variable and contains the following:

\begin{enumerate}
	\item the pc-s which represent the lexical scope of the variable, \ie the pc-s in between the square brackets 	
	\item the name of the variable
	\item the index/slot at which the variable is stored (starting at index 0) and
	\item the type of the variable.
\end{enumerate}

In our example, \textit{this} reference has the lexical scope of the whole method, thus pc starts at 0 and ends with 13. \textit{This} reference is the first one in the table, hence it is indexed with 0, and its type is class \code{HelloWorld}. The indexes of the the local variable table are important because we use them to get the right local variable we are interested in.

Let us now look at a more complicated example of the local variable table. Consider the source code example \coderef{localVarTableDuplicatedSlot1SourceCode} which contains a method \code{void loadDrawing(String filename)}. The bytecode of this example is shown in the \bytecoderef{localVarTableDuplicatedSlot1}.
This method consists of a \code{try-catch} block. 
We see that the variable \code{url} \chk{(declared at line 3 in \coderef{localVarTableDuplicatedSlot1SourceCode},  stored at line 4 in \bytecoderef{bytecodeOfLocalVarTableDuplicatedSlot1SourceCode} and contained in the entry at line 4 in \bytecoderef{localVarTableDuplicatedSlot1})} is only accessible within the \code{try\{\}} block. 
\chk{The \code{try\{\}} block starts with pc 0 and ends with pc 40 and the variable \code{url} is accessible from pc 13 onwards until pc 40 ([pc: 13, pc: 40]), as it can be seen in the local variable table in \bytecoderef{bytecodeOfLocalVarTableDuplicatedSlot1SourceCode}.}

The local variable \code{url} is stored at the index 2 in the local variable table in \bytecoderef{localVarTableDuplicatedSlot1}, since the first two indexes occupy \textit{this} reference and the method parameter.
As soon as the lifespan of a local variable ends, the slot can be reused by the next instantiated local variable. 
So, onward the pc 40, slot 2 is free again. 
The freed slot can be immediately used by the next declared variable, which is the variable \code{e} in our example. 
Looking at line 7 in \bytecoderef{localVarTableDuplicatedSlot1} we see that \code{e} also has the slot number 2. This is why we can find local variable tables that contain multiple entries with the same local variable slot.

%===============================================================================
\section{Javassist}
\label{sec:javassist}

\textit{Javassist} or \textit{Java Programming Assistant}\footnote{\url{http://jboss-javassist.github.io/javassist/}}~\cite{Chib00}~\cite{Chib03}, a subproject of JBoss, is a library which enables manipulation of the Java bytecode. Since 1999 it is used as an engineering toolkit in a broad domain, and is still being extended by Shigeru Chiba. It enables developers to manipulate Java bytecode in a simplified way. Examples of this manipulation include defining a new class at runtime or modifying a class file when it is loaded by the JVM. All manipulations are performed at load-time through a provided class loader. A tutorial for using Javassist\footnote{\url{http://jboss-javassist.github.io/javassist/tutorial/tutorial.html}} is available online and was used as a starting point for this work.

Unlike many other bytecode manipulation libraries, Javassist offers two levels of API: \textbf{source}-level and \textbf{bytecode}-level. Using the source-level API, the user can edit a class file without any familiarity with the specifications of the Java bytecode. Knowledge of the Java language is enough since the API is designed only with the vocabulary of Java. On this level the programmer has to write Java source code and Javassist compiles it automatically. The bytecode level allows the user to modify classes by modifying the bytecode directly.

%\begin{figure}[H]
%\centering
%\includegraphics[width=0.8\linewidth]{javassistLevel}
%\caption{Bytecode modification levels.}
  %\label{fig:bytecodeModificationLevels}
%\end{figure}

%In \figref{bytecodeModificationLevels}\footnote{Figure taken from \href{https://blog.newrelic.com/2014/09/29/diving-bytecode-manipulation-creating-audit-log-asm-javassist/}{blog.newrelic.com}.} the term \textit{``Low Level''} is used for \textit{bytecode}-level and \textit{``High Level''} for \textit{source}-level. Using the libraries \textit{ASM} and \textit{BCEL} \brs{links or refs to these libs}the user has to construct bytecode itself and is not able to only write simple source code to modify a class file. The library \textit{AspectJ} on the other hand only allows the user to write source code which is than translated into bytecode. This way of course the user is limited by the functionality of the library \textit{AspectJ}. \textit{Javassist}\brs{not consistent, sometimes textit sometimes not. I don't see why it should be textit, I receomend droping it} and \textit{CGLIB} provide the user the choice of whether to work on \textit{bytecode}- or \textit{source}-level, or even on both. \brs{this whole story about ``levels'' is important because...}\lt{figure shows that javassist can use both apis.. take out?}

Let us look at the small example shown in \coderef{javassistExample}\footnote{Example taken from Javassist tutorial.} of how the bytecode manipulation with Javassist works. We go through the example line by line.

\renewcommand\lstlistingname{Code}
\begin{Java}[caption={Javassist example. With this example we explain how Javassist can be used.}, label={code:javassistExample}][H]
ClassPool pool = ClassPool.getDefault();
CtClass cc = pool.get("test.Rectangle");
cc.setSuperclass(pool.get("test.Point"));
cc.writeFile();
\end{Java}

\begin{enumerate}
	\item First a \textit{ClassPool} object that controls bytecode modification is obtained. With the \textit{ClassPool} object a class file (``.class'') can be read on demand for constructing a \textit{CtClass} object.

	\item The class \textit{CtClass} (compile-time class) represents the class file. This means that all manipulations are performed on the \textit{CtClass} object. We obtain a reference to the \textit{CtClass} object representing the \code{test.Rectangle} class by invoking the \code{get()} method on the \textit{ClassPool} instance.

	\item In this example the only bytecode modification done is changing the superclass of \code{test.Rectangle} to \code{test.Point}. This change serves only for illustration.

	\item Once the bytecode modification is done, the method call \code{writeFile()} on the instance of \textit{CtClass} is necessary to make sure that the changes are reflected on the original class file. The method \code{writeFile()} converts the modified \textit{CtClass} object into a class file and stores it on a local disk.
\end{enumerate}

\begin{figure}[H]
\centering
\includegraphics[width=0.8\linewidth]{javassistModules}
\caption{Javassist modules.}
  \label{fig:javassistModules}
\end{figure}

\figref{javassistModules}\footnote{Figure taken from \href{https://blog.newrelic.com/2014/09/29/diving-bytecode-manipulation-creating-audit-log-asm-javassist/}{blog.newrelic.com}.} gives an overview of how the main part of bytecode manipulation with Javassist is built up. The \textit{ClassPool} is simply a container of multiple \textit{CtClasses}. As described before \textit{CtClass} represents a class file on which modifications are done. Like typical classes, it can hold compile-time fields, constants or methods. Javassist is capable of adding or modifying classes, behaviors, fields, method invocations, local variables \etc But in our case we mainly address the manipulation of behaviors. It is possible to insert additional source code at the beginning of a method body, at the end or at a specific line. 

\renewcommand\lstlistingname{Code}
\begin{Java}[caption={Initial code.}, label={code:initialCode}][H]
public static void main(String[] args) {
	System.out.println("This is an example class.");
}
\end{Java}

\renewcommand\lstlistingname{Bytecode}
\begin{JVMIS}[caption={Initial bytecode.}, label={bytecode:initialBytecode}, numbers=left, breaklines=true][H]
public static void main(java.lang.String[]);
  0: getstatic     #16	// Field java/lang/System.out:Ljava/io/PrintStream;
  3: ldc           #22	// String This is an example class.
  5: invokevirtual #24	// Method java/io/PrintStream.println:(Ljava/lang/String;)V
  8: return
\end{JVMIS}

The next example (\coderef{bytecodeModifier}) shows how to add code by using Javassist.
We want to add one line of code at the beginning of the \code{main()} method in \coderef{initialCode}. \bytecoderef{initialBytecode} is the corresponding bytecode of \coderef{initialCode}.

\renewcommand\lstlistingname{Code}
\begin{Java}[caption={Bytecode modifier.}, label={code:bytecodeModifier}][H]
public class BytecodeModifier {
	public static void main(String[] args) ... {
		ClassPool pool = ClassPool.getDefault();
		CtClass cc = pool.get("insertJavaCodeExample.ExampleClass");

		CtBehavior behavior = cc.getDeclaredMethod("main");
		behavior.insertBefore("System.out.println(\"This is the inserted code.\");");

		cc.writeFile();

		//...
	}
}
\end{Java}

We first obtain a \textit{CtClass} object \code{cc} (\coderef{bytecodeModifier} line 4) which represents the class to be modified. At line 6 we get the \textit{CtMethod} object \code{behavior} which represents the method we want to modify (in our case, method \code{main()}). We modify the method by adding the source code \code{System.out.println(``This is the inserted code.'');} at the beginning of the method. Because we want to insert code at the beginning of the method we invoke the method \code{insertBefore()} at line 7. If we wanted to enter additional code at the end of the method we could have called the analogue method \code{insertAfter()}. Both methods \code{insertBefore()} and \code{insertAfter()} expect an argument of type String, which Javassist then compiles, and adds into the bytecode at the specified location (in our situation at the beginning of the \code{main()} method).

If the modified bytecode (\bytecoderef{modifiedBytecode}) were to be decompiled, its source code representation is shown in the \coderef{modifiedCodeDecompiled}. A the line 2 of this code, we can see the changes, \ie the inserted line of code. But the actual result is the inserted bytecode represented by the pc-interval <0,5> in the modified bytecode (\bytecoderef{modifiedBytecode}).

\renewcommand\lstlistingname{Bytecode}
\begin{JVMIS}[caption={Modified bytecode. The modification is visible from line 0 to 4.}, label={bytecode:modifiedBytecode}, numbers=left, breaklines=true][H]
public static void main(java.lang.String[]);
  0: getstatic     #16 	// Field java/lang/System.out:Ljava/io/PrintStream;
  3: ldc           #35	// String This is the inserted code.
  5: invokevirtual #24	// Method java/io/PrintStream.println:(Ljava/lang/String;)V
  8: getstatic     #16	// Field java/lang/System.out:Ljava/io/PrintStream;
 11: ldc           #22	// String This is an example class.
 13: invokevirtual #24	// Method java/io/PrintStream.println:(Ljava/lang/String;)V
 16: return
\end{JVMIS}

\renewcommand\lstlistingname{Code}
\begin{Java}[caption={Modified code: Decompiled with JAD (\secref{jad})}, label={code:modifiedCodeDecompiled}][H]
public static void main(String args[]) {
	System.out.println("This is the inserted code.");
	System.out.println("This is an example class.");
}
\end{Java}

%===============================================================================
\section{JAD}
\label{sec:jad}

Java Decompier (JAD)\footnote{\url{https://sourceforge.net/projects/jadclipse/}} is a decompiler and an Eclipse plugin for the programming language Java. A decompiler is a program that takes an executable file as input, and attempts to create a high level, compatible source file. If the source file is compiled again, it will produce an executable program that behaves the same way as the original one. It is often used in software reverse engineering.

The example \bytecoderef{jad} is decompiled by JAD and the result is the source code shown in \coderef{decompiledBytecode}.

\renewcommand\lstlistingname{Bytecode}
\begin{JVMIS}[caption={This bytecode example serves as a demonstration code to be compiled with JAD.}, label={bytecode:jad}, breaklines=true]
public void itemStateChanged(java.awt.event.ItemEvent e);
  0  aload_1 [e]
  1  invokevirtual java.awt.event.ItemEvent.getStateChange() : int [23]
  4  iconst_1
  5  if_icmpne 22
  8  aload_0 [this]
  9  getfield org.jhotdraw.applet.DrawApplet$1.this$0 : org.jhotdraw.applet.DrawApplet [12]
 12  aload_1 [e]
 13  invokevirtual java.awt.event.ItemEvent.getItem() : java.lang.Object [29]
 16  checkcast java.lang.String [33]
 19  invokevirtual org.jhotdraw.applet.DrawApplet.loadDrawing(java.lang.String) : void [35]
 22  return
Line numbers:
 [pc: 0, line: 213]
 [pc: 8, line: 214]
 [pc: 22, line: 216]
Local variable table:
 [pc: 0, pc: 23] local: this index: 0 type: new org.jhotdraw.applet.DrawApplet(){}
 [pc: 0, pc: 23] local: e index: 1 type: java.awt.event.ItemEvent
\end{JVMIS}

\renewcommand\lstlistingname{Code}
\begin{Java}[caption={The result of the decompiled bytecode shown in \bytecoderef{jad}.}, label={code:decompiledBytecode}]
public void itemStateChanged(ItemEvent e) {
	if(e.getStateChange() == 1)
		loadDrawing((String)e.getItem());
}
\end{Java}
 
JAD is in no way a dependency of NullSpy but it was a big help during the implementation phase since after running NullSpy on a project only the modified bytecode is available. The use of JAD is for the sake of debugging NullSpy; to check whether the modification made by Javassist, \ie inserting source code, was successful. Another way to check the result for correctness is looking at bytecode itself but that would have taken a lot more effort and time.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                   NullSpy                                    %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{NullSpy}

As explained in \charef{introduction}, this project is about providing the user with an additional link next to the common stack trace containing the location of a \textit{null} assignment to the variable that caused the \npe. \chk{We use the term \textbf{link} to address the line which includes the information where the variable that caused the \npe was assigned null, and which we add to the common stack trace.}

In this chapter we give an overview of how we implemented NullSpy. We will also address the challenges (\secref{challenges}) we encountered during the implementation as well as the limitations of the tool (\secref{limitations}).

%===============================================================================
\section{High Level Overview}
\label{sec:highLevelOverview}

The general approach of NullSpy is to statically analyze a project in which \npe occurs and instrument the corresponding bytecode. NullSpy is a console application which takes two arguments. The first argument to NullSpy is the local path to the folder containing the compiled class files of the original project and the second one is the path to the folder in which the user wants to store the modified class files.

We provide the option to choose the destination in case the developer does not want to overwrite the original project with the modified one. This means that the updated bytecode can be stored in another location, keeping the original class files intact. Of course the original project can also be replaced by the modified one. To sweep away the instrumented bytecode, the developer has to recompile the source code to get the original class files when needed.

\begin{figure}[H]
\centering
\includegraphics[width=0.8\linewidth]{highLevelOverview3}
\caption{High level overview.}
  \label{fig:highLevelOverview}
\end{figure}

NullSpy contains three basic steps which we can see in \figref{highLevelOverview}: \textit{load, modify, store}. Those three steps of NullSpy carry out the following actions:

\begin{enumerate}
	\item Input: Load compiled class files of the project into NullSpy.
	\item Modification: The modification part deals with the bytecode instrumentation and adding modules to the project that support the inserted code.
	\item Output: Store modified class files to the chosen output folder.
\end{enumerate}

Loading is done by traversing through all the subfolders of the folder whose local path was given as a first parameter, and extracting all the \textit{.class} files. NullSpy modifies the class file directly when it is loaded. As soon as the modification is done, the class file is stored at the destination folder \ie the folder whose path is the second parameter of NullSpy. The structure of the source folder is preserved also at the destination folder.

%\chg{Storing is done by recreating the structure from the source folder in the destination folder. \ugh{and storing the modified class files.  using the Javasist API.}}{The structure of the source original folder is preserved also at the destination folder.} \nm{I would not mention JavaAssist here, no need for it.}

%\del{In secref{javassist} we store the modified class file on a local disk. This way the original class file remains intact. In our case we write the modified class file in the destination folder not only on a local disk. This way the original project can be overwritten as explained before.} \brs{what? not only on a local disk? what does that even mean}\lt{ask, javassist tutorial store on local disk, here write new file or overwrite}

%===============================================================================
\section{Low Level Overview}
\label{sec:lowLevelOverview}

In this section we will focus on the bytecode modification. \figref{modificationModules} shows that the modification part of NullSpy contains three different modules. Each class file of the loaded project will be run through the first two modules and the last module is only added once to the modified project at the end of the instrumentation process.

After class loading, we first extract data from the class bytecode and then instrument it.

\begin{figure}[H]
\centering
\includegraphics[width=0.8\linewidth]{lowLevelOverview}
\caption{NullSpy modification modules.}
  \label{fig:modificationModules}
\end{figure}

We will look at these modules in more detail and explain what each one does.

%-------------------------------------------------------------------------------
\subsection{Process Flow}
\label{subsec:processFlow}
In this short and rough overview of the entire process we explain the reason why we have to extract data from bytecode and what they are used for. Details are discussed in the following subsections.

From the stack trace of a \npe we can obtain three kinds of information: the class name, method name and the line number of where the \npe happened. The aim of NullSpy is to reveal the location of the null assignment to the variable which caused the \npe. To achieve this goal we need to take information from the bytecode about \textbf{\mrs} and \textbf{null assignments}.

The first step in the modification part is to statically gather information about the \mrs. We use the term \textbf{\mr} to refer to variables on which methods are invoked, or whose fields are accessed.
These variables are candidates for triggering a \npe.
For each \mr we extract the information needed to create its unique identifier (details about this are listed in \subsecref{methodReceiver}). 
These identifiers are used later to track the assignments to the aforementioned variable, and to find the null assignment entry for this variable, if any.

The second step is to instrument the assignments. For every non-primitive variable assignment we collect information about the variable, needed to create its unique identifier. After the assignment we insert code which represents a call to the \textbf{run-time supporter} package with the variable's identifier. The run-time supporter package checks at run-time whether the variable is assigned null. If this is the case we store the information about this variable.

At the end of the bytecode modification part we wrap the \code{main()} method into a \textit{try-catch-block}. This block extract from the \npe stack trace the information about the location where the exception happened (class name, method name, line number). This is the only information we can get from a stack trace. This information is passed on to the run-time supporter package which compares it with the stored identifiers about the \mrs. If there is a match regarding the comparison, NullSpy uses this identifier to reveal the information stored about the assignments to this variable. If there is an entry about the null assignment of that variable, we extract from it the line number of the assignment and create the additional link that reveals the location of the null assignment. This link is then added to the common \npe stack trace.

%\brs{everything in this subsection after this point makes no sense to me. ``As soon as a \npe is thrown'' how do we know when it's thrown? ``sequentially compare data'' what does this even mean?}
%
%\chk{To summarize the last three paragraphs:
%As soon as a \npe is thrown, we extract data from the \npe stack trace and information about the \mr and the null assignments. We then sequentially compare those data with each other to get the right location of the null assignment.} The comparison-sequence looks as follows (we use the symbol ``\textbf{$\|$}'' for the comparison):
%
%\begin{enumerate}
	%\item \npe data \textbf{$\|$} \mrs data $\rightarrow$ \mr-identifier
	%\item \mr-identifier \textbf{$\|$} null assignment data $\rightarrow$ \textbf{result}
%\end{enumerate}
%
%Result contains the data needed to create the link to the null assignment.
%
%Finally we add the \textit{run-time supporter} module to the modified project.

The way how we extract and store all those data are discussed in the following sections.

%-------------------------------------------------------------------------------
\subsection{\MR Data Collection}
\label{subsec:methodReceiver}
In this section we explain how to get information about the \mr needed to construct a unique identifier. \Mrs in the example \coderef{methodReceiverAlgDemoCode} are the variables \code{fToolButton} at line 7, \code{fToolButton.myIcon} at line 8 and \code{activePanel} at line 11.

We use the library Javassist to partially extract this data from bytecode. Unfortunately, Javassist does not provide the functionality to directly get all the information we need about the \mr, thus we need to do it manually. 

\renewcommand\lstlistingname{Code}
\begin{Java}[caption={Code snippet to demonstrate the \mr extracting algorithm.}, label={code:methodReceiverAlgDemoCode}]
public class DrawApplication {

	private ToolButton fToolButton;

	protected void open(final DrawingView newDrawingView) {
	...
	(@\textbf{fToolButton}@).tool();			   // field access
	(@\textbf{fToolButton.myIcon}@).toString();	// field access
		
	JPanel activePanel = new JPanel();		
	(@\textbf{activePanel}@).add((Component) getDesktop(), BorderLayout.CENTER);	// local variable as a method receiver
	...
	}
}
\end{Java}

\renewcommand\lstlistingname{Bytecode}
\begin{JVMIS}[numbers=left, caption={Bytecode of \coderef{methodReceiverAlgDemoCode}.}, label={bytecode:methodReceiverAlgDemoBytecode}, breaklines=true]
144  aload_3 [activePanel]
145  aload_0 [this]
146  invokevirtual org.jhotdraw.application.DrawApplication.getDesktop() : org.jhotdraw.contrib.Desktop [271]
149  checkcast java.awt.Component [274]
152  ldc_w <String "Center"> [276]
155  invokevirtual javax.swing.JPanel.add(java.awt.Component, java.lang.Object) : void [254]
\end{JVMIS}

\textbf{Finding the invocation opcode/end-pc}\\
Let us suppose that we are interested in the \mr \code{activePanel} of the method invocation \code{add(...)} at line 11 in the example \coderef{methodReceiverAlgDemoCode}.
Its bytecode is presented in \bytecoderef{methodReceiverAlgDemoBytecode}.

To get data about \mrs we iterate through the bytecode looking for the instructions which represent a method invocation.
To do this, NullSpy looks for the opcodes which matches the regex \textit{``invoke.*''}. Each of these opcodes represents one method invocation. There are exactly five invocation bytecode instructions in Java: \textit{invokedynamic}, \textit{invokeinterface}, \textit{invokespecial}, \textit{invokestatic}, \textit{invokevirtual}.

For each method invocation we want to find the method receiver. 
In our example bytecode instruction which matches the invocation of the method \code{add(...)} is at the line 6 in \bytecoderef{methodReceiverAlgDemoBytecode}.
Since bytecode lists method receiver and all the method parameters before the \textit{``invoke.*"} instruction, the pc of this \textit{``invoke.*''} opcode will represent the \textbf{end-pc} \chk{of the method invocation pc-interval}. In our example, the end-pc of the method invocation \code{add(...)} is 155.

\textbf{Finding the start-pc}\\ 
The \textbf{start-pc} \chk{of the method invocation pc-interval} is the pc at which begins the bytecode which represents the source code line, containing the invocation. Finding the start-pc is done by using the line number table of the method. We compare the \textbf{end-pc} with the \chk{entries of the line number table and take the last entry which has the smaller pc than the \textbf{end-pc}. The line number table of the example bytecode is shown in \bytecoderef{mrBytecodeExampleLineNumberTable}.}. 
The \textbf{start-pc} in our example is 144.

\renewcommand\lstlistingname{Bytecode}
\begin{JVMIS}[caption={Part of the line number table of the example bytecode shown in \bytecoderef{methodReceiverAlgDemoBytecode}.}, label={bytecode:mrBytecodeExampleLineNumberTable}, breaklines=true]
Line numbers:
	...
	[pc: 136, line: 10]
	(@\textbf{[pc: 144, line: 11]}@)
	[pc: 158, line: 12]
	...
\end{JVMIS}

We define the outermost \textbf{pc-interval} as the interval starting with the \textbf{start-pc} and ending with the \textbf{end-pc}. We know that the \mr is located in this interval. In our example, this is <144,155>.

\textbf{Extracting candidate \mr pc-intervals}\\
The outermost interval <144,155> could contain other invocations, which could have \mrs of their own. This is visible in our example, where the \code{getDesktop()} invocation (pc 146) is embedded in our outermost interval. For this reason, we explored all possible bytecode combinations of instructions that can represent \mrs and developed a system for identifying such embedded call sights. More about this system can be found in the Appendix (\ref{cha:bytecodeCombinations}). This system allows us to split the outermost pc-interval into candidate \mr pc-intervals. In our example, the outermost pc-interval is divided into \{<144,144>,<145,149>,<152,152>\}. Each of the pc-intervals represents:

\begin{enumerate}
	\item <144,144>: variable \code{activePanel}
	\item <145,149>: first parameter \code{(Component) getDesktop()}
	\item <152,152>: second parameter \code{BorderLayout.CENTER}
\end{enumerate}

\textbf{Finding the actual \mr}\\
The set of candidate pc-intervals ends with the arguments of the method.
Javassist allows us to obtain the number of parameters of a method invocation by analyzing the method signature. 
Thus, if the method expects $N$ arguments, we can ignore the last $N$ candidate pc-intervals. The one before them is the actual \mr pc-interval. 
In our example, since the method takes two arguments, the actual \mr pc-interval is <144,144>.

If the \mr is actually return object from another method invocation, it is unapparent where exactly the \mr is situated in bytecode. More about the challenges we encountered can be found in \subsecref{methodReceiverDifficulties}.

In case of the simple stand-alone \textit{invokestatic} instruction we do have a \mr but NullSpy ignores these instructions because static method invocations are called on classes which can never be null. But if the static method call is a parameter of another method call, NullSpy still treats it as a \mr candidate. As for the other \textit{invoke} instructions, they are treated normally as explained.

With the \mr pc-interval we extract the information needed to create a unique \mr identifier from the bytecode by using Javassist API.
We get the index of the \mr by using Javassist (in our example the index is 3), and with this index and pc information of the \mr, \chk{we can obtain the needed information from the local variable table shown in \bytecoderef{mrBytecodeExampleLocalVariableTable}.}

\renewcommand\lstlistingname{Bytecode}
\begin{JVMIS}[caption={Part of the local variable table of the example bytecode shown in \bytecoderef{methodReceiverAlgDemoBytecode}.}, label={bytecode:mrBytecodeExampleLocalVariableTable}, breaklines=true]
Local variable table:
	...
	[pc: 100, pc: 340] local: activePanel index: 3 type: javax.swing.JPanel
	...
\end{JVMIS}

\chk{The next listing shows a part of the extracted information about the \mr to create its unique identifier:}
\begin{itemize}
	\item source code line number of the method receiver
	\item name of the class and signature of the method containing the method invocation
	\item full variable name
	\item statically declared variable type
\end{itemize}

The exact information we need can be found in the Appendix \ref{cha:appReceivers}.

%-------------------------------------------------------------------------------
\subsection{Assignments Collection}
\label{subsec:variable}

%In the precious section we were looking for instructions which match the regex \textit{``invoke.*''} to detect \mrs in bytecode. 
To find the assignments in the bytecode we search for the instructions matching regexs \textit{``astore.*''} and \textit{``put.*''}. The former refers to local variable assignments and the latter to field assignments. 
%Unlike the information collection of the \mr, the data about the variables are stored in a HashMap, since it needs to be used at run time.

In the next two subsections we will look at how the information about the assigned variables is extracted. Due to different variable types and the limitation of Javassist, the ways of gathering information about the local variables and fields are performed differently.

\subsubsection{Local Variable}
\label{subsubsec:localVariable}
Unfortunately, Javassist does not provide any support for gaining information about local variables, thus we needed to do it manually. 
%This is why we have to understand how the bytecode is constructed concerning the local variables. 
%In \secref{bytecode} we introduced the parts of the bytecode that are important for our project NullSpy.

%We have to pay attention to get the right local variable every time we encounter one while iterating through bytecode. 
Every time we hit upon the opcode \textit{``astore.*''}  (which represents an assignment to a local variable) we get the index of the variable and the pc of the assignment instruction. A local variable has a limited lifespan. As we have already seen in \secref{bytecode} multiple entries can have the same local variable slot (one variable takes the index of the other whose lifespan expired).

\begin{JVMIS}[numbers=left, caption={Local variable table entries with same slot 2 (line 4 and7).}, label={bytecode:localVarTableDuplicatedSlot}, breaklines=true]
Local variable table:
 [pc: 0, pc: 95] local: this index: 0 type: org.jhotdraw.samples.javadraw.JavaDrawViewer
 [pc: 0, pc: 95] local: filename index: 1 type: java.lang.String
 (@\textbf{[pc: 13, pc: 40] local: url index: 2 type: java.net.URL}@)
 [pc: 18, pc: 40] local: stream index: 3 type: java.io.InputStream
 [pc: 28, pc: 40] local: reader index: 4 type: org.jhotdraw.util.StorableInput
 (@\textbf{[pc: 44, pc: 94] local: newTool index: 2 type: org.jhotdraw.framework.Tool}@)
\end{JVMIS}

\begin{JVMIS}[numbers=left, caption={Local variable assignment at pc 45.}, label={bytecode:localVarAssignment}, breaklines=true]
Local variable table:
	...
	37  aload_0 [this]
	38  invokevirtual org.jhotdraw.samples.javadraw.JavaDrawViewer.getCodeBase() : java.net.URL [100]
	41  aload_1 [filename]
	42  invokespecial java.net.URL(java.net.URL, java.lang.String) [104]
	(@\textbf{45  astore\_2 [url]}@)
	...
\end{JVMIS}
    
Let us assume that we have a local variable assignment where its \textit{``astore\_2''} opcode is located at pc 45 (\bytecoderef{localVarAssignment}). In this example we can extract slot 2 from the opcode \textit{astore\_2}. After extracting the slot (index: 2) we iterate through the local variable table and find the first entry which contains that slot (line 4 in \bytecoderef{localVarTableDuplicatedSlot}). If the pc of the assignment is not included in the local variable lifespan of the entry (pc 45 $\notin$ [pc: 13, pc: 40], line 4), the next entry with the same slot (pc 45 $\in$ [pc: 44, pc: 94], line 7) will be examined. Checking the entries with the same slot goes on until both criteria slot and pc fits. Once those criteria are met we can be positive about having the right local variable table entry to extract the information needed to create a unique identifier for the variable. We now extract from local variable table the information we need to create a unique identifier for a variable. \chk{A part of the extracted information is listed below:}
\begin{itemize}
	\item source code line number of the assignment
	\item name of the class and method signature containing the local variable
	\item local variable name
	\item statically declared local variable type
\end{itemize}

The exact list of the information we extract can be found in the Appendix \ref{cha:appLocalVars}.

\begin{JVMIS}[numbers=left, caption={Line number table.}, label={bytecode:lineNrTable}]
  Line numbers:
        [pc: 0, line: 58]
        [pc: 13, line: 59]
        [pc: 18, line: 60]
        [pc: 28, line: 61]
        [pc: 40, line: 62]
        [pc: 43, line: 63]
        (@\textbf{[pc: 44, line: 64]}@)
        [pc: 52, line: 65]
        [pc: 74, line: 66]
        [pc: 94, line: 68]
\end{JVMIS}

On the other hand, by using the pc of the assignment (45) and line number table (shown in \bytecoderef{lineNrTable}) we obtain the source code line number of the assignment. As we can see in the table, the local variable assignment starts at source code line 64.

\subsubsection{Instance and Class/Static variable (Field)}
\label{subsec:field}
Although Javassist does not support the access to information about local variables it provides a way to access information about fields. Javassist allows us to modify an expression in a method body by using the class \code{Javassist.expt.ExprEditor}. 
%In our case we only want to extract some information about the fields instead of any modification, nevertheless this class can be used appropriately. 
It scans the bytecode for instructions like \textit{``putfield''} for instance fields or \textit{``putstatic''} for static fields, and allows us to directly get the information we need to create a unique identifier for the field. \chk{Next we list a part of the information we are interested in:}
\begin{itemize}
	\item source code line number of the assignment
	\item name of the class and method signature containing the field assignment
	\item full field name
	\item statically declared field type
\end{itemize}

During the data collection about the fields we encountered some difficulties which we will discuss in \subsecref{variableDifficulties}.

As already mentioned earlier, every time when encountering an assignment either to a local variable or a field, NullSpy inserts bytecode which checks at run time whether the variable is assigned null. If the variable is assigned null, NullSpy stores all the data about the variable.

%-------------------------------------------------------------------------------
\subsection{Bytecode Adaptation}
\label{bytecodeAdaptation}
Each time we encounter a variable assignment we first extract the data about the variable and then we add our own bytecode right after the assignment bytecode. The inserted bytecode checks at run time whether the value being assigned to the variable is null. If this is the case, we store the previously explained information about this assignment.

The explanation of the way we do it can be found in the Appendix \ref{cha:appInstrumentation}.

Once we have gone through the bytecode of all the class files, the modified class files are stored in the destination directory as mentioned in \secref{highLevelOverview}. After the instrumentation we add out supplementary supporter classes to the project. The most important ones are \code{VariableTester}\footnote{\label{package1}In package \emph{ch.scg.nullSpy.runtimeSupporter}} which tests whether a variable is null and \code{NullDisplayer}\textsuperscript{\ref{package1}} which matches data and prints the location of a null assignment when a \npe is thrown.

%===============================================================================
\section{Challenges}
\label{sec:challenges}

In this section we would like to present some of the difficulties we encountered during the implementation of NullSpy.

%-------------------------------------------------------------------------------
\subsection{Obtaining \MR Data Difficulties}
\label{subsec:methodReceiverDifficulties}
Aforementioned in \subsecref{methodReceiver} we were encountered with a persistent problem, namely getting the pc-interval of the \mr when the interval covers multiple lines in source code. In many development environment the written code can be formatted automatically and as well manually. 

\begin{Java}[caption={Method invocation split in two lines example.}, label={code:4-1}, firstnumber=31]
Image image = Iconkit.instance().registerAndLoadImage(
	(Component)view, imageName);
\end{Java}

%\renewcommand\lstlistingname{Bytecode}
%\begin{JVMIS}[caption={Bytecode to \coderef{4-1}.}, label={bytecode:4-2}, breaklines=true]
 %0  invokestatic org.jhotdraw.util.Iconkit.instance() : org.jhotdraw.util.Iconkit [22]
 %3  aload_1 [view]
 %4  checkcast java.awt.Component [28]
 %7  aload_0 [this]
 %8  getfield org.jhotdraw.samples.minimap.MiniMapDesktop.imageName : java.lang.String [14]
%11  invokevirtual org.jhotdraw.util.Iconkit.registerAndLoadImage(java.awt.Component, java.lang.String) : java.awt.Image [30]
%14  astore_2 [image]
%\end{JVMIS}

\begin{JVMIS}[caption={Line number table/interval to \coderef{4-1}.}, label={bytecode:4-3}, breaklines=true, firstnumber=1]
[pc: 0, line: 31]
[pc: 3, line: 32]
[pc: 11, line: 31]
\end{JVMIS}

Let us now look at an example that contains the situation where a method invocation is split into tow lines. The example is shown in \coderef{4-1}. The method invocation \code{registerAndLoadImage(...)} is formatted the way where it does not have enough space in one line. This cannot be figured out by just looking at the bytecode, therefore the line number attribute (\bytecoderef{4-3}) has to be consulted. 

Beforehand we have to say that there is no \mr in \coderef{4-1} because the \mr would contain a method invocation itself. NullSpy does not support \mrs which are return objects of method invocations. To enable the coverage of such situations can be a topic of future works. Other \mrs NullSpy does not support are elements of collections due to its complex structures that can be stored in the collections.

\renewcommand\lstlistingname{Code}
\begin{Java}[caption={Alternating line number example.}, label={code:3-1}, firstnumber=127]
Connector oldConnector = ((ChangeConnectionHandle.UndoActivity)
			getUndoActivity()).getOldConnector();
\end{Java}

%\renewcommand\lstlistingname{Bytecode}
%\begin{JVMIS}[caption={Bytecode to \coderef{3-1}.}, label={code:3-2}, breaklines=true]
%47  aload_0 [this]
%48  invokevirtual org.jhotdraw.standard.ChangeConnectionHandle.getUndoActivity() : org.jhotdraw.util.Undoable [72]
%51  checkcast org.jhotdraw.standard.ChangeConnectionHandle$UndoActivity [76]
%54  invokevirtual org.jhotdraw.standard.ChangeConnectionHandle$UndoActivity.getOldConnector() : org.jhotdraw.framework.Connector [142]
%57  astore 7 [oldConnector]
%\end{JVMIS}

\begin{JVMIS}[caption={Line number table/interval to \coderef{3-1}.}, label={bytecode:3-3}, breaklines=true, numbers=left]
[pc: 47, line: 128]
[pc: 51, line: 127]
[pc: 54, line: 128]
[pc: 57, line: 127]
\end{JVMIS}

Only looking at bytecode is not enough, so we are looking at the line number attribute. Line number \textit{31} (\bytecoderef{4-3}) is listed twice, this indicates that the method invocation is split into multiple lines in source code. The former declares the starting point of the interval and the latter the end of it. Line 32 indicates the starting point of parameter loading. How we get the pc-interval will be presented shortly. But before that we take a look at more examples.

Special about the example shown in \coderef{3-1} is that the multiple line interval does not start with the smaller line number and end with the bigger one. Apart from that the pc is alternated stored in the line number attribute shown in \bytecoderef{3-3}. The line number table indicates followings:

\begin{enumerate}
	\item line 1: the method invocation \code{getUndoActivity()}
	\item line 2: the cast to \code{ChangeConnectionsHandle.UndoActivity}
	\item line 3: the second method invocation \code{getOldConnector()}
	\item line 4: the assignment to the variable \code{oldConnector}
\end{enumerate}

\renewcommand\lstlistingname{Code}
\begin{Java}[caption={Nested interval example.}, label={code:2-1}, firstnumber=149]
for (int i = 0; i < ColorMap.size(); i++)
	choice.addItem(
		new ChangeAttributeCommand(
			ColorMap.name(i),
			attribute,
			ColorMap.color(i),
			this
		)
	);
\end{Java}

%\renewcommand\lstlistingname{Bytecode}
%\begin{JVMIS}[caption={Bytecode to \coderef{2-1}.}, label={code:2-2}, breaklines=true]
 %8  iconst_0
 %9  istore_3 [i]
%10  goto 37
%13  aload_2 [choice]
%14  new org.jhotdraw.standard.ChangeAttributeCommand [213]
%17  dup
%18  iload_3 [i]
%19  invokestatic org.jhotdraw.util.ColorMap.name(int) : java.lang.String [246]
%22  aload_1 [attribute]
%23  iload_3 [i]
%24  invokestatic org.jhotdraw.util.ColorMap.color(int) : java.awt.Color [252]
%27  aload_0 [this]
%28  invokespecial org.jhotdraw.standard.ChangeAttributeCommand(java.lang.String, org.jhotdraw.framework.FigureAttributeConstant, java.lang.Object, org.jhotdraw.framework.DrawingEditor) [222]
%31  invokevirtual org.jhotdraw.util.CommandChoice.addItem(org.jhotdraw.util.Command) : void [225]
%34  iinc 3 1 [i]
%37  iload_3 [i]
%38  invokestatic org.jhotdraw.util.ColorMap.size() : int [256]
%41  if_icmplt 13
%\end{JVMIS}

\begin{JVMIS}[numbers=left, caption={Line number table/interval to \coderef{2-1}.}, label={bytecode:2-3}, breaklines=true]
[pc: 8, line: 149]
[pc: 13, line: 150]
[pc: 14, line: 151]
[pc: 18, line: 152]
[pc: 22, line: 153]
[pc: 23, line: 154]
[pc: 27, line: 155]
[pc: 28, line: 151]
[pc: 31, line: 150]
[pc: 34, line: 149]
\end{JVMIS}

Neither in bytecode nor in line number attribute we can extract the exact interval of method invocations. Another interesting thing is that in the line number table (\bytecoderef{2-3}) of the example shown in \coderef{2-1} shows multiple corresponding line numbers, \eg lines 1\&10 or lines 2\&9. Again, we examine the line number table: 

\begin{enumerate}
	\item line 1: starting point of the for-loop
	\item line 2: starting point of the method invocation \code{addItem(...)}
	\item line 3: \code{new ChangeAttributeCommand(...)} starting point\\or parameter loading 
	\item line 4-7: parameter loading 
	\item line 8: actual object creation
	\item line 9: actual call to \code{addItem(...)}
	\item line 10: for-loop incrementation or its ending
\end{enumerate}

\renewcommand\lstlistingname{Code}
\begin{Java}[caption={Incomplete interval example.}, label={code:5-1}, firstnumber=22]
var_1
	.method_1(staticMethod_1(),
		staticMethod_2(param_1),
		var_2.method_2(null,
			param_2));
\end{Java}

%\renewcommand\lstlistingname{Bytecode}
%\begin{JVMIS}[caption={Bytecode to \coderef{5-1}.}, label={code:5-2}, breaklines=true]
%18  aload_1 [var_1]
%19  invokestatic staticMethod_1() : java.lang.Object [26]
%22  aload_3 [param_1]
%23  invokestatic staticMethod_2(java.lang.Object) : java.lang.Object [30]
%26  aload_2 [var_2]
%27  aconst_null
%28  aload_3 [param_2]
%29  invokevirtual method_2(java.lang.Object, java.lang.Object) : java.lang.Object [34]
%32  invokevirtual method_1(java.lang.Object, java.lang.Object, java.lang.Object) : void [38]
%\end{JVMIS}

\begin{JVMIS}[caption={Line number table/interval to \coderef{5-1}.}, label={code:5-3}, breaklines=true]
[pc: 18, line: 22]
[pc: 19, line: 23]
[pc: 22, line: 24]
[pc: 26, line: 25]
[pc: 28, line: 26]
[pc: 29, line: 25]
[pc: 32, line: 23]
\end{JVMIS}

By only using the algorithm of extracting the pc-interval of a \mr (described in \subsecref{methodReceiver}) we would get the wrong outermost pc-interval of a method invocation, when the invocation is split into multiple lines. To handle this mistake we implemented a supporting class named \code{MultipleLineManager}\footnote{\label{package2}In package \emph{ch.unibe.scg.nullSpy.instrumentator.controller.methodInvocation}.}. Its responsibility is to extract the outermost pc-interval of invocations in split line situations. How we implemented it is very complex. That is why we skip the explanation of how the extraction works and would recommend to to look at the class \code{MultipleLineManager} if interested.

\todo{leave this or not write about the multiple line stuff.}

%only get the pc-interval <47,>, but actually pc 18 also belongs to the interval. That the missing pc is missing will be detected in step 4\&5 when traversing back the ArrayList by the number of parameters. If it is not a static method invocation and there is not enough possible \mrs stored in that ArrayList to traverse back, the missing pc is added in retrospect.
%
%\renewcommand\lstlistingname{Pseudocode}
%\begin{Java}[caption={Multiple line interval algorithm.}, label={alg:multipleLineAlg}]
%i = index in line number attribute which contains the invoke.* opcode
%
%if (lineNrAttribute[j>i] <= lineNrAttribute[i]) {
%
	%if (isAlternating(i,j))
		%return getAlternatingInterval(i, j);
%
	%// non-alternating
	%b = j which has the smallest line number after j;
	%a = corresponding index to b; // index<k which has the same line number as b||k
	%return getNonAlternatingInterval(a, b);
%
%} else if (lineNrAttribute[j<i] == lineNrAttribute[i]) {
%
		%b = i;
		%a = j;
		%return getInterval(a, b);
%
%}
%\end{Java}
%
%This pseudocode will give a very rough idea how the invocation interval can be read out. The detailed implementation can be seen in the classes \code{MultipleLineManager}\footnote{\label{package2}In package \emph{ch.unibe.scg.nullSpy.instrumentator.controller.methodInvocation}.} and \code{MethodInvocationAnalyzer}\textsuperscript{\ref{package2}}.

%-------------------------------------------------------------------------------
\subsection{Obtaining Assignment Data Difficulties - Fields}
\label{subsec:variableDifficulties}
We mentioned that NullSpy first collects data about fields with help of the class \code{Javassist.expt.ExprEditor}. That class uses the method \code{loopBody(...)} to iterate through bytecode of a method and scans for specific opcodes, in our place we are only interested into the opcodes which matches the regex \textit{``put.*''}. One parameter passed to the method \code{loopBody(...)} is the \code{mehodInfo} object which contains the bytecode sequence of the method we want to instrument.

Since the \code{loopBody(...)} is invoked within a \code{while-loop}, it iterates through the given \code{methodInfo} until it reaches the end of the bytecode sequence. When it goes through the byte sequence we instrument the bytecode. But because the changes made on the bytecode is updated after the \code{while-loop}, the method \code{loopBody(...)} still finds the specific opcodes at locations within the origin bytecode sequence instead of the modified one.

Due to this situation had difficulties finding the right \textbf{start-pc} of field assignments. The class \code{FieldAnalyzer}\footnote{In package \emph{ch.unibe.scg.nullSpy.instrumentator.controller}.} serves as the explanation of how we still managed to find the \textbf{start-pc} of a field assignment.

%This method caused us some.  troubles because it loops through the GIVEN \code{methodInfo} which contains the bytecode sequence of a method. Even after finding a field assignment and adding bytecode to it, the method still iterates through the unchanged \code{methodInfo} it got as parameter without the additional bytecode. Getting the right start-pc of a field assignment is not a straight forward process as it may seem.
%
%After entered extra instructions the method \code{loopBody()} iterates onwards until it finds a key which indicates an access to a field. Normally, Javassist provides a method with which the start-pc of the field access can be find out easily, but in our case not due to bytecode alternation. This method returns the start-pc of the field as if there was no changes, however it actually has to return a bigger start-pc than it does. The start-pc is needed to distinguish in what category the field has to be assigned to (\subsecref{field}).
%
%To find the right start-pc of the field assignment, we compare the start-pc returned by a method of Javassist with the \code{afterStorePc} of the previously found field assignment. Every time an assignment is found we store it as a reference for the next assignment to obtain the right data. Even for the store-pc of an assignment (\textit{``put.*"} the last found field is essential. If there is more interest how those pcs are obtained, please see the class \code{FieldAnalyzer}\footnote{In package \emph{ch.unibe.scg.nullSpy.instrumentator.controller}.}.

%-------------------------------------------------------------------------------
\subsection{Bytecode Adaptation Difficulties}
\label{subsec:bytecodeAdaptationDifficulties}
The reason why we decided to use Javassist for our NullSpy project was due to the thought of only using the source-level API for the instrumentation. \ugh{It would have been much easier to only operate at source-level instead of learning to read bytecode, yet we still had to do everything at bytecode-level at the end.}

One big problem we encountered was the insertion of our code between a variable assignment and a closing bracket \code{\}}. We tried to insert code as shown in \figref{insertionCodeExample} by specifying the exact line number where we want to enter in source code. Unfortunately Javassist first checks the specified line whether it contains some code (standalone symbols and Java keywords excluded). If there is no code at the specified line, Javassist computes the next line containing some code and inserts our code right before that line. Let us look at a situation where for example the local variable \code{var} is assigned a value at the end of a \code{if-body} at line 3 in \coderef{bytecodeAdaptationExample_1}. In this situation Javassist adds the extra code right before the next code line which is the beginning of the \code{else-body} (line 5 in \coderef{bytecodeAdaptionExample_2}). So our added code to check the local variable \code{var} for its value can not be reached. 

\renewcommand\lstlistingname{Code}
\begin{Java}[caption={Bytecode adaptation example.}, label={code:bytecodeAdaptationExample_1}]
Object var;
if (...) {
	var = ...;
} else {
	var = ...;
}
\end{Java}

\begin{Java}[caption={Wrong Adaptation to \coderef{bytecodeAdaptationExample_1}.}, label={code:bytecodeAdaptionExample_2}]
Object var;
if (...) {
	var = ...;
 } else {
	--<inserted code to check the variable var at line 3>--
	var = ...;
}
\end{Java}

Due to this problem we changed the way to insert our code at bytecode-level. This way we first have to build up the bytecode sequence and then enter it before a specific pc. How we build the bytecode sequence is explained in .

There are more problems during the implementation of NullSpy but we mentioned the most troublesome ones in this subsection.

%===============================================================================
\section{Limitations}
\label{sec:limitations}

During the implementation of NullSpy we had to change the concept few times due to limitations or an overhead that could have grown immense.

Our first idea of how NullSpy could track the \npes is to gather information about variable assignment, which is the case now, and also inject another test method right before each method invocations. In small projects this way could have worked fine but in larger projects which could contain hundreds of classes with a lot of method invocations the execution time would be strongly influenced.

\lt{rewrite the next three paragraphs}

Being able to collect data about variables we still have to instrument bytecode even it affects the performance. Related to this issue a limitation about Javassist is mentioned before, namely the insertion of bytecode right before a closing bracket (\subsecref{bytecodeAdaptationDifficulties}). 
By using the source-level API of Javassist we could not insert bytecode between a source code line and a closing braclet \code{\}}. Due to this reason we changed the way to instrument bytecode. NullSpy now uses the bytecode-level API of Javassist.
%Because of this it highly depends on the location where additional code should be inserted whether using the source-level API is possible or not. \ugh{Avoiding checking all the location where something new should be added it is more secure to do this on bytecode-level.}\lt{Ã¤ndern} But in cases like entering something at the beginning or at the end of a method body the source-level is just fine.

Another limitation of Javassist to mention is that it does not provide anything to get information about \mrs. It only allows one to extract information about local variables, fields and method invocations itself. The programming language Java also does not provide any information about the \mr, since the exception object or the stack trace element only contains the class, file, method name and the line number. Nonetheless making possible to gather data about them the algorithm discussed before (see \algref{methodReceiverAlg}) fulfills the missing task.

The last limitation we want to discuss here is that unfortunately NullSpy is not capable to track the root of \npes that are originated in a null which was returned of a method call or in an element of a collection. Why those situations are not supported in NullSpy is because of the impossibility way to store them, e.g. imagine a nested ArrayList or a HashMap and a never ending return value of method invocations. So we lack something tangible to compare with each other, get a hit and read the location out of the hit (\secref{futureWork}).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                  Validation                                  %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Validation}
\label{ch:validation}

This chapter will provide some numbers to compare the execution time each project takes, the original and the instrumented one. To get the numbers we instrumented the example project JHotDraw.

%===============================================================================
\section{JHotDraw}
\label{sec:jhotdraw}

{JHotDraw\footnote{\protect\url{http://www.jhotdraw.org/}}} also served to check whether the logic of the bytecode manipulation behind NullSpy is working as desired. JHotDraw is an open-source Java GUI framework for technical and structured Graphics. It is big enough to get reliable numbers and it provides many different cases we had to take care of in NullSpy. Also thanks to Nevena Milojkovi\'{c} and her experience with the combination Javassist and JHotDraw we as well decided to test NullSpy on it.

%===============================================================================
\section{Execution Time Difference}
\label{sec:execTimeDiff}

JHotDraw already provides an Ant buildfile \textit{built.xml} that packs the project into an executable jar file. We modified the buildfile a little bit so that it also creates a jar file out of the modified project stored in the destination the user has chosen before. The steps to create an executable jar of the modified project are followings: load project, modify project, store modified project, build project that creates jar file of the original project and one of the modified one. We then simulate the terminal with a Java class to run the tests included in each jar file thirty times, each time it returns the execution time. At the end we calculate the average time for the original and the modified project. The the execution times are listed in \tabref{executionTime} and the average times are shown in \tabref{averageTime}.

\begin{table}[H]
\centering
\begin{tabular}{ l | S[table-format=1.3] | S[table-format=1.3]|}
\cline{2-3}	  &\textbf{Original project} & \textbf{Modified project}\\ \cline{2-3}
	1	& 7.223	& 7.442	\\ \cline{2-3}
	2	& 7.427	& 7.738	\\ \cline{2-3}
	3	& 7.171	& 7.893	\\ \cline{2-3}
	4	& 7.035	& 7.379	\\ \cline{2-3}
	5	& 7.488	& 7.458	\\ \cline{2-3}
	6	& 7.194	& 7.691	\\ \cline{2-3}
	7	& 6.849	& 7.472	\\ \cline{2-3}
	8	& 7.286	& 8.068	\\ \cline{2-3}
	9	& 7.083	& 7.519	\\ \cline{2-3}
	10 & 7.27	& 7.55	\\ \cline{2-3}
	11 & 7.16	& 7.177 \\ \cline{2-3}
	12 & 7.161  & 7.55	\\ \cline{2-3}
	13 & 7.225	& 7.223	\\ \cline{2-3}
	14 & 7.037	& 7.316	\\ \cline{2-3}
	15 & 7.067	& 7.54	\\ \cline{2-3}
	16 & 6.975	& 7.77	\\ \cline{2-3}
	17 & 7.287	& 7.117	\\ \cline{2-3}
	18 & 7.52	  & 7.488	\\ \cline{2-3}
	19 & 7.303	& 7.35	\\ \cline{2-3}
	20 & 6.942	& 7.307	\\ \cline{2-3}
	21 & 7.147	& 7.535	\\ \cline{2-3}
	22 & 7.222	& 7.644	\\ \cline{2-3}
	23 & 7.145	& 7.32	\\ \cline{2-3}
	24 & 7.334	& 8.187	\\ \cline{2-3}
	25 & 7.364	&7.488	\\ \cline{2-3}
	26 & 7.269	&7.942	\\ \cline{2-3}
	27 & 7.441	&7.943	\\ \cline{2-3}
	28 & 7.223	&7.467	\\ \cline{2-3}
	29 & 6.912	&7.647	\\ \cline{2-3}
	30 & 7.363	&7.784	\\ \cline{2-3}
	\cline{2-3}
	\end{tabular}
	\caption{Execution time.}
	\label{tab:executionTime}
\end{table}

\begin{table}[H]
	\centering
	\begin{tabular}{ | S[table-format=1.4] | S[table-format=1.6] |}
		\hline
		\textbf{Original project} & \textbf{Modified project}\\ \hline
		7.2041	&	7.566834 \\
		\hline
	\end{tabular}
	\caption{Average time.}
	\label{tab:averageTime}
\end{table}

The runtime of the modified project takes 0.362734s longer than the original one, this means after adding additional code to the project results in approximately \textbf{5\%} overhead. This small overhead is quite negligible. But this numbers have to be interpreted with caution because the overhead is only measured on JHotDraw.

%===============================================================================
\section{NullSpy demonstration on a real project}
\label{sec:demonstration}
We want to demonstrate on a real project how the project NullSpy helps the user to find the real culprit that leads to a \npe. The example shown in \coderef{demonstration} will be the real world project NullSpy supports.

The \code{main()} method at line 6 invokes sequential three methods (\code{makeReader()}, \code{readNumbers()}, \code{closeReader}) and prints out the field \code{numbers}. In make \code{makeReager()} method it tries to read a file named ``file.txt''. If the example does not find that file, it will execute the catch-block and assign null to the field \code{reader} at line 18.

Of course the call to \code{readNumbers()} at line 8 is not important for our demonstration, that is why we skip it.

The \npe is triggered when the method \code{closeReader()} is called. There is an attempt at line 39 to close the reader. But because the field \code{reader} is assigned null, the method call \code{close()} causes the \npe. Since only the \textit{IOException} is caught there the \npe goes up the call hierarchy until the \code{main()} method. As discussed in \subsecref{processFlow}, in the catch-block of \code{main()} we extract information from the \npe stack trace, multiple comparisons are performed and finally the link to the null assignment and the \npe stack trace are displayed. The resulting stack trace is presented in \stacktraceref{demonstrationStackTrace}.

\begin{Java}[caption={NullSpy demonstration example.}, label={code:demonstration}]
public class Ideone {

	public static List<Integer> numbers;
	public static BufferedReader reader;

	public static void main(String[] args) {
		makeReader();
		readNumbers();
		closeReader();
		System.out.println(numbers);
	}

	// Buggy, reader should not be null if there is no file to read
	private static void makeReader() {
		try {
			reader = new BufferedReader(new FileReader(new File("file.txt")));
		} catch (FileNotFoundException e) {
			reader = null;
		}
	}

	// Not really important.
	private static List<Integer> readNumbers() {
		try {
			List<Integer> numbers = new ArrayList<Integer>();
			String text = null;
			while ((text = reader.readLine()) != null) {
				numbers.add(Integer.parseInt(text));
			}
			return numbers;
		} catch (Exception e) {
			return new ArrayList<Integer>();
		}
	}

	// NPE triggered here!
	private static void closeReader() {
		try {
			reader.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
}
\end{Java}

\begin{figure}[H]
\renewcommand\figurename{Stack trace}
	\begin{boxedminipage}{\textwidth}
		\color{cadmiumred}
		Field this.reader at line 18 is null: (\textcolor{blue}{Ideone.java: 18})\\
		Exception in thread "main" \textcolor{blue}{java.lang.NullPointerException}\\
		\tab at Ideone.closeReader(\textcolor{blue}{Ideone.java:39})\\
		\tab at Ideone.main(\textcolor{blue}{Ideone.java:9})
	\end{boxedminipage}
	\caption{Stack trace of the demonstration example \coderef{demonstration}.}
	\label{stacktrace:demonstrationStackTrace}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                          Conclusion and Future work                          %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter {Conclusion and Future Work}
\label{ch:conclusionFutureWork}

Now we have come so far to retrospect (step back and have a critical loot at) the entire project for summarizing what goals we have achieved so far and for proposing further aims that could be completed in the future. In a small section we also want to talk about the gained experience during the whole project.

%===============================================================================
\section{NullSpy}
\label{sec:nullSpy}

Happily, we could say here that we successfully managed to meet the main purpose we have set at the beginning of the project. NullSpy is now capable to tracking the \npes to its root and provide the user with more information about its origin without spending much time on finding it. The most important steps which lead to the success of NullSpy are listed below:

\begin{enumerate}
\item Extract and gather information about all \mrs because method invocations on these causes \npes. To achieve this, we developed an algorithm (\algref{methodReceiverAlg}) with the function of finding \mrs and extracting data from it by only doing static bytecode analysis. The information about it is then stored as an external csv file. It is needed for a comparison in in a later step.

\item Again collecting data, but this time about variable assignments namely local variables and fields. Here next to the static bytecode analysis additional instructions are inserted to the class files to check right after the assignment if the variable is assigned to the special value \code{null}. If this is the case everything about the variable is stored in a HashMap which serves for a comparison too. It is stored in a HashMap because if a variable is assigned to another object than null, it will be deleted from the HashMap.

\item NullSpy does only handle the uncaught \npe which means we can wrap up the \code{main()} method with a catch block. In this catch block the class name and the line number where the \npe occurred is extracted from the stack trace. This information is passed to a method in which the parameter helps to find the guilty \mr. With the hit the exact location where that variable was set to null can be derived from the HashMap.

\item All the additional needed classes are added to the project after it is modified and stored in a folder the user has chosen. Being able to run the modified project of course a jar file is created. In our case JHotDraw already provides a \textit{build.xml} which we had to alternate a little bit.
\end{enumerate}

During the implementation we were encountered with many difficulties. Some of those we were able to solve and some not unfortunately. Those unsolved ones could be proposed as goals of future work. The next section will list some of them.

%===============================================================================
\section{Future Work}
\label{sec:futureWork}

%-------------------------------------------------------------------------------
\subsection{Support unsupported \mrs and variable assignments}
As mentioned in (\secref{limitations}), if the cause of a \npe lies in an element of a collection or in an object that is returned by a method invocation, it cannot be tracked to its assignment location. Come up with a way to extract and store information could be a future aim. Of course gathering information about the \mrs has to be improved too.

%-------------------------------------------------------------------------------
\subsection{Track \npe root for all projects}
As now our goal in this project was tracking null assignments of JHotDraw. First of all, we had to make sure that building JHotDraw works properly with the additional classes. To fulfil this task manual changes on the build.xml was necessary. If this can be done automatically by NullSpy it would be much better.

Next to this we only looked at the assignment and \mr types which appear in JHotDraw itself. There could be other types that are not covered in NullSpy depending on projects. In case NullSpy is used on projects that contain not supported issues improving it to cover them can be added to the toDo list.

%-------------------------------------------------------------------------------
\subsection{Plug-in for Eclipse}
Last target for future work to mention here is transform NullSpy into an Eclipse compatible plug-in project. After integrated it with Eclipse the null tracking can be started without any expenses on how to manipulate the build.xml if there is one or even bother to create an executable jar file out of it.

For now, we can only think of these future work that could improve NullSpy to give it more value.

%===============================================================================
\section{Personal Experience}

At the beginning, after reading the description of the project I had no clue how to approach its goal at all. Since this is my first big project on my own but with help from two experienced research assistants I learned a lot, especially in the matter of programming.

As the project is all about manipulating class files, here with Javassist, we first had to learn how bytecode is constructed and get familiar with Javassist. Luckily there is a very good tutorial that teaches one how to use it. This class library however does not cover everything we needed. Thanks to this we had to deal with the lack extensively and learned quite a lot about working on bytecode-level.

Next to getting familiar with bytecode we also had to invent algorithms like that of extracting \mrs from the bytecode or that of getting the pc-interval of a \mr. It was quite interesting to invent those as these are the first ones that fulfill more complex tasks.

Debugging: It is not as easy as it seems. Sometimes it took hours to find the cause of a small bug, and after fixing it another occurs. The reason why it took that long to debug is because along with checking whether the logic of our code was right we also had to find the right bytecode position to ensure the implementation does what it is created for.

Coding beautifully the way so that it will not smell was another challenge due to lack of experience. Sometimes I tended to put everything in one class instead of abiding by the single responsibility principle. Therefore, refactoring the whole project multiple times was necessarily which also took some time. Best before starting to code is to clearly thinking through what is needed, how the structure should look like and what kind of responsibility each class of the project should take for gaining time for other things.

We also came in contact with the building XML file and the jar file. Concerning the XML file, we gained experience by learning a new language by modifying it that it also creates a jar file out of the modified project.



%END Doc
%-------------------------------------------------------
\bibliographystyle{plain}
\bibliography{scg}


\begin{appendices}

% A N L E I T U N G  Z U  W I S S E N S C H A F T L I C H E N  A R B E I T E N
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\chapter {Anleitung zu wissenschaftlichen Arbeiten}
NullSpy is a program which helps Java developers to find the root of \npes by providing an additional link next to the common stack trace. The key idea behind NullSpy is to help developers to save time fixing bugs which are caused by \npe. Of course this approach tries to provide this service by keeping the overhead to a minimum. To demonstrate how NullSpy works, this chapter serves as a small tutorial that takes JHotDraw as the testing project to show the feature of NullSpy.

%===============================================================================
\section{Installation}
\label{sec:installation}

For this tutorial JHotDraw is needed. In order to download it, visit the following site and download ``JHotDraw6.0 beta 1'' (version we worked with during the implementation of NullSpy):\\
\href{http://www.jhotdraw.org}{www.jhotdraw.org}\\
Unpack the archive and store it to a location of your choice. To be able to run JHotDraw additional libraries are used, that are not included in JHotDraw itself. Following libraries are to be downloaded:\\
``batik-all-1.7'': \href{http://www.java2s.com/Code/Jar/b/Downloadbatikall17jar.htm}{www.java2s.com/Code/Jar/b/Downloadbatikall17jar}\\
``jdo'': \href{http://www.java2s.com/Code/Jar/j/Downloadjdojar.htm}{www.java2s.com/Code/Jar/j/Downloadjdojar}\\
Again unpack those archives and store them in a lib folder in your JHodDraw project.

Running the tests of JHotdraw with the commando line the location of libraries ``hamcrest'' and ``junit'' are needed, which are normally also downloaded when the programming environment Eclipse\footnote{Can be downloaded here: \href{https://eclipse.org/downloads/}{www.eclipse.org/downloads}} is downloaded.

\chapter{Bytecode combinations of \mrs}
\label{cha:bytecodeCombinations}
In \subsecref{methodReceiver} we discussed about extracting all possible combinations of \mrs which are embedded in the outermost interval. We developed a system for identifying them by using the following list shown in \listref{methodReceiverTemplate}.

\begin{figure}[H]
\renewcommand\figurename{List}
	\begin{boxedminipage}{\textwidth}
		\begin{itemize}
		\itemsep8pt
		\item local variable
		\begin{itemize}
			\item aload													y
			\item aload.getfield 								y
			\item aload.getfield.getfield...		y	(if fields are public)
			\item aload.getstatic								n	(aload = ref, getstatic = arg)
			\item aload.aload\_0									n	(aload = ref, this.getfield etc = args
			\item aload.aload										n	(aload = ref, aload = arg)
			\item aload.new											n	(aload = ref, new = arg)
		\end{itemize}

		\item non-static field
		\begin{itemize}
			\item aload\_0												y	(aload\_0 = ref for private method)
			\item aload\_0.getfield							y
			\item aload\_0.getfield.getfield. ..	y	(if getfields are public fields)
			\item aload\_0.this									n	(aload\_0 = ref, this... = arg)
			\item aload\_0.getfield.getstatic		n (!exist)
			\item aload\_0.getstatic							n	(aload\_0 = ref, getstatic = arg)
			\item aload\_0.aload									n	(aload\_0 = ref, aload = arg)
			\item aload\_0.new										n	(aload\_0 = ref, new = arg)
		\end{itemize}

		\item static field
		\begin{itemize}
			\item getstatic											n	(ignore, because getinvoke)
			\item getstatic.aload								n
			\item getstatic.aload\_0							n
			\item getstatic.new									n
			\item getstatic.getstatic						n (!exist)
			\item getstatic.getfield						y
			\item getstatic.getfield.getfield.	y	(getfields are public field)
		\end{itemize}
   \end{itemize}
	\end{boxedminipage}
	\caption{\Mr template.}
	\label{list:methodReceiverTemplate}
\end{figure}

While we iterate through the invocation pc-interval and run into the opcode \eg \textit{``aload.*''} we check what comes after this opcode. If \textit{getfield} is the following opcode, we know that the bytecode represents a field access of a local variable or of the current analyzed class depending on which local variable slot the opcode \textit{``aload.*''} refers to. Next again, we check the next opcode after \textit{getfield} and so on until the following opcode does not fit into the allowed pattern of the template. As long as the checked opcode fits into our template, we consider them as one possible \mr.

If the following opcode after the first \textit{``aload.*} is another \textit{``aload.*} we can be sure that they are two separate \mr candidate because two local variables does not have any relationship with each other. Even if the first opcode is a \textit{aload\_0}.

With this system we iterate through the outermost invocation pc-interval and split it into candiate \mr pc-intervals.

\chapter{Method receivers}
\label{cha:appReceivers}
\todo{Work on this}

In this section we explain how to get information about the \mr needed to construct a unique identifier. \Mrs in the example \coderef{methodReceiverAlgDemoCode} are the variables \code{fToolButton} at line 7, \code{fToolButton.myIcon} at line 8 and \code{activePanel} at line 11.

%\renewcommand\lstlistingname{Code}
%\begin{Java}[caption={\Mr example.}, label={code:methodReceiverExample}]
%public class A {
%
	%private Object (@\textbf{field}@) = new Object();
	%private Object b = new B();
%
	%public static void main() {
		%Object (@\textbf{var}@) = new Object();
%
		%(@\textbf{var}@).toString();	// local variable on which method is invoked
		%(@\textbf{field}@).toString();	// field access
		%(@\textbf{b.foo}@).toString();	// field access
	%}
%}
%
%public class B {
	%public Object foo = new Object();
	%..
%}
%\end{Java}

We use the library Javassist to partially extract this data from bytecode. Unfortunately, Javassist does not provide the functionality to directly get all the information we need about the \mr, thus we need to do it manually. The exact information we need is listed in \listref{methodReceiverInfo} and it is stored in an external \textit{csv} file due to overhead minimization.

\begin{figure}[H]
\renewcommand\figurename{List}
	\begin{boxedminipage}{\textwidth}
		\begin{itemize}
		\itemsep8pt
   	\item \mr counter (\mrs are counted)
		\item source code line number of the method receiver
		\item name of the class containing the method invocation
		\item name of the method which contains the invocation
		\item parameter types and return type of the method which contains the invocation
		\item is the variable a local variable or a field
		\item is variable static or not
		\item variable name
		\item statically declared variable type
		\item name of the class declaring the variable, if the variable is a field, else empty string
		\item attribute index, if the variable is a local variable, else empty string
   \end{itemize}
	\end{boxedminipage}
	\caption{\Mr information.}
	\label{list:methodReceiverInfo}
\end{figure}

To get this data, we need the \textit{pc-interval} of the \mr.
Let us have a look at line 11 of the example source code shown in \coderef{methodReceiverAlgDemoCode} and its bytecode presented in \bytecoderef{methodReceiverAlgDemoBytecode}. In this example we want to extract the pc-interval of the \mr \code{activePanel} which is a method receiver of the \code{add(...)} method invocation.
We will now explain the steps to get the pc-interval of the \mr \code{activePanel}, \ie <144,144>.

\textbf{Finding the invocation opcode/end-pc}\\
While iterating through the bytecode, NullSpy looks for the opcodes which matches the regex \textit{``invoke.*''}. Each of these opcodes represents one method invocation. For each method invocation we want to find the method receiver. Since bytecode first lists method receiver and all the method parameters, the pc of this \textit{``invoke.*''} opcode will represent the \textbf{end-pc} of a method invocation. In our example, the end-pc of the method invocation \code{add(...)} is 155.

\textbf{Finding the start-pc}\\ 
The pc at which the bytecode which represents the source code line, containing the invocation, begins is called \textbf{start-pc}. Finding the start-pc is done by using the line number table of the method. We compare the end-pc with the start-pc-s for each line of code, and take the last one which is smaller than the end-pc. This table is omitted from our example for simplicity. The start-pc is 144.

\renewcommand\lstlistingname{Code}
\begin{Java}[caption={Code snippet to demonstrate the \mr extracting algorithm.}, label={code:appMethodReceiverAlgDemoCode}]
public class DrawApplication {

	private ToolButton fToolButton;

	protected void open(final DrawingView newDrawingView) {
	...
	(@\textbf{fToolButton}@).tool();			   // field access
	(@\textbf{fToolButton.myIcon}@).toString();	// field access
		
	JPanel activePanel = new JPanel();		
	(@\textbf{activePanel}@).add((Component) getDesktop(), BorderLayout.CENTER);	
	// local variable as a method receiver
	...
	}
}
\end{Java}

\renewcommand\lstlistingname{Bytecode}
\begin{JVMIS}[numbers=left, caption={Bytecode of \coderef{methodReceiverAlgDemoCode}.}, label={bytecode:appMethodReceiverAlgDemoBytecode}, breaklines=true]
144  aload_3 [activePanel]
145  aload_0 [this]
146  invokevirtual org.jhotdraw.application.DrawApplication.getDesktop() : org.jhotdraw.contrib.Desktop [271]
149  checkcast java.awt.Component [274]
152  ldc_w <String "Center"> [276]
155  invokevirtual javax.swing.JPanel.add(java.awt.Component, java.lang.Object) : void [254]
\end{JVMIS}

\textbf{Defining the outermost pc-interval}\\
We define the outermost \textbf{pc-interval} as the interval starting with the start-pc and ending with the end-pc. We know that the \mr is located in this interval. In our example, this is <144,155>.

\textbf{Getting the number of parameters for the method}\\
By using Javassist we obtain the number of parameters of a method invocation by analyzing the method signature. Our example method takes two  parameters.

\textbf{Extracting candidate \mr pc-intervals}\\
The outermost interval <144,155> could contain other invocations, which could have \mrs of their own. This is visible in our example, where the \code{getDesktop()} invocation (pc 146) is embedded in our outermost interval. For this reason, we explored all possible bytecode combinations of instructions that can represent \mrs and developed a system for identifying such embedded call sights. More about this system can be found in the appendix (\ref{cha:bytecodeCombinations}). This system allows us to split the outermost pc-interval into candidate \mr pc-intervals. In our example, the outermost pc-interval is divided into \{<144,144>,<145,149>,<152,152>\}. Each of the pc-intervals represents:

\begin{enumerate}
	\item <144,144>: variable \code{activePanel}
	\item <145,149>: first parameter \code{(Component) getDesktop()}
	\item <152,152>: second parameter \code{BorderLayout.CENTER}
\end{enumerate}

\textbf{Finding the actual \mr}\\
Since the set of candidate pc-intervals ends with the arguments of the method, and we know that the method expects $N$ arguments, we can ignore the last $N$ candidate pc-intervals. The one before them is the actual \mr pc-interval. In our example, since the method takes two arguments, the actual \mr pc-interval is <144,144>.

If the \mr is actually return object from another method invocation, it is unapparent where exactly the \mr is situated in bytecode. More about the challenges we encountered can be found in \subsecref{methodReceiverDifficulties}.

Statically analyzing bytecode for \mr means looking for certain opcodes which matches the regex \textit{``invoke.*''}. There are exactly five such bytecode instructions in Java: \textit{invokedynamic}, \textit{invokeinterface}, \textit{invokespecial}, \textit{invokestatic}, \textit{invokevirtual}.

In case of the simple stand-alone \textit{invokestatic} instruction we do have a \mr but it can be ignored because static method invocations are called on classes which can never be null. NullSpy ignores these instructions. But if the static method call is a parameter of another method call, NullSpy still treats it as a \mr candidate. As for the other \textit{invoke} instructions, they are treated normally.

With the \mr pc-interval we extract the information listed in \listref{methodReceiverInfo} from the bytecode by using Javassist API.

\chapter{Local variables assignments}
\label{cha:appLocalVars}

The full information we need to create a unique identifier for a local variable is listed in \listref{localVarInfo}.

\begin{figure}[H]
\renewcommand\figurename{List}
	\begin{boxedminipage}{\textwidth}
\begin{itemize}
		\itemsep8pt
		\item source code line number of the local variable
		\item name of the class containing the local variable
		\item name of the method which contains the local variable
		\item parameter types and return type of the method which contains the invocation
    \item is the variable a local variable or a field
		\item local variable name
		\item statically declared local variable type
		\item attribute index
		\item local variable slot
		\item start-pc: the pc where the local variable assignment actually starts
		\item store-pc: the pc of the \textit{``astore.*''} opcode
		\item after-pc: the next pc after store-pc; before that pc we insert our code
   \end{itemize}
	\end{boxedminipage}
	\caption{Local variable information.}
	\label{list:localVarInfo}
\end{figure}

\chapter{Field assignments}

There are only two instructions that indicates an access to a field, but there are actually many different types of fields. To get the meaning of different types see \listref{fieldKeywords}.

\begin{figure}[H]
\renewcommand\figurename{List}
	\begin{boxedminipage}{\textwidth}
		(\textbar\dots\textbar: put value on operand stack for assigning to a field)
\begin{enumerate}
\itemsep8pt
      \item aload\_0, \textbar\dots\textbar, putfield
      \item \textbar\dots\textbar, putstatic
			\item aload.*, \textbar\dots\textbar, putfield
			\item aload\_0, (getfield)+, \textbar\dots\textbar, putfield
			\item getstatic, (getfield)*, \textbar\dots\textbar, putfield
   \end{enumerate}
	\end{boxedminipage}
	\caption{Field keywords.}
	\label{list:fieldKeywords}
\end{figure}

Depending on the category a field belongs to, different kind of information is stored about it. Number one in \listref{fieldKeywords} indicates fields of the currently analyzed class and number two can be static fields either of the current analyzed class or others classes. What Information we need about these fields accessing is listed in \listref{variableInfo1}.

\begin{figure}[H]
\renewcommand\figurename{List}
	\begin{boxedminipage}{\textwidth}
		\begin{itemize}
			\itemsep8pt
			\item source code line number of the local variable
			\item name of the class containing the field assignment
			\item name of the method which contains the field assignment
			\item parameter types and return type of the method which contains the field assignment
			\item is the variable a local variable or a field
			\item class name in which the field is declared		
			\item is field static or not
			\item field name
			\item statically declared field type
			\item start-pc: the pc where the field assignment actually starts
			\item store-pc: the pc of the \textit{``put.*''} opcode
			\item after-pc: the next pc after store-pc; before that pc we insert our code
	  \end{itemize}
	\end{boxedminipage}
	\caption{Field information (I).}
	\label{list:variableInfo1}
\end{figure}

In NullSpy we use the term \textbf{member field} to describe a field of another class than the class being analyzed. Such fields are listed as number 3-5 in \listref{fieldKeywords}.
We call everything before the instruction \textit{``putfield''} \textbf{member object}. For those fields more data are needed to store for their identification. The same information as listed in \listref{variableInfo1} is needed plus additional data listed in \listref{variableInfo2}.

\begin{figure}[H]
\renewcommand\figurename{List}
	\begin{boxedminipage}{\textwidth}
		\begin{itemize}
			\itemsep8pt
			\item is the member object a local variable or a field
			\item class name in which the member object is declared	
			\item is member field static or not
			\item member object name
			\item statically declared member object type
   \end{itemize}
	\end{boxedminipage}
	\caption{Additional member object information (II).}
	\label{list:variableInfo2}
\end{figure}

The synthetic example \coderef{fieldExample} shows how exactly the instructions \textit{``putfield''} and \textit{``putstatic''} are used.

\renewcommand\lstlistingname{Code}
\begin{Java}[caption={Synthetic example to show how the instructions \textit{``putfield''} and \textit{``putstatic''} are used.}, label={code:fieldExample}]
public class A {

	private B b = new B();
	private static B b2;

	public void x() {

		// |...|: value assigned to fields

		// fields
		this.b = ...; 	// aload_0, |...|, putfield
		b2 = ...; 		// |...|, putstatic

		B b3 = new B();

		// member fields
		b3.c = ...; 	// aload.*, (getfield)*, |...|, putfield
		b3.c.d = ...

		b.c = ...; 		// aload_0, (getfield)+, |...|, putfield
		b.c.d = ...;

		b2.c = ...; 	// getstatic, (getfield)*, |...|, putfield
		b2.c.d = ...;
	}
}

public class B {
	public C c = new C();
	..
}

public class C {
	public D d = new D();
	..
}

public class D {
	..
}
\end{Java}

\chapter{Bytecode instrumentation}
\label{cha:appInstrumentation}
The added bytecode represents a static method of a class named \code{VariableTester}\footnote{\label{package1}In package \emph{ch.scg.nullSpy.runtimeSupporter}.} which is added to the modified project after bytecode modification is done. Depending on what kind of variable (local variable, field) is analyzed, different bytecode is constructed, which means the bytecode represents different methods which accepts different parameter/variable data.

In \secref{javassist} we mentioned that the library makes it possible to modify bytecode either with the source- or bytecode-level API. Due to a limitation of Javassist (\secref{limitations}) we modify the class file at bytecode-level by creating a \textit{bytecode-array} and include it in the file. \coderef{bytecodeCreation} shows the way how the inserted bytecode is created.

\begin{Java}[caption={Inserted bytecode(-array) creation.}, label={code:bytecodeCreation}, firstnumber=1]
private byte[] getInsertCodeByteArray(Variable var) {
	Bytecode testMethodByteCode = new Bytecode(cp);

	testMethodByteCode.addLdc(behavior.getDeclaringClass()
		.getName());
	testMethodByteCode.addLdc(behavior.getName());
	testMethodByteCode.addLdc(behavior.getSignature());
	testMethodByteCode.addLdc(varID);
	testMethodByteCode.addLdc(varName);
	testMethodByteCode.addLdc(varType);

	Field field = (Field) var;

	String fieldDeclaringClassName = field
		.getFieldDeclaringClassName();

	testMethodByteCode.addLdc(fieldDeclaringClassName);

	// int 1 -> static, 0 -> nonStatic
	if (field.isStatic()) {
		addIntegerToBytecode(testMethodByteCode, 1);
	} else {
		addIntegerToBytecode(testMethodByteCode, 0);
	}

	testMethodByteCode.addAload(0);
	testMethodByteCode.addGetfield(
		fieldDeclaringClassName varName, varType);

	addIntegerToBytecode(testMethodByteCode, var.getVarLineNr());
	addIntegerToBytecode(testMethodByteCode, var.getStartPc());
	addIntegerToBytecode(testMethodByteCode, var.getStorePc());
	addIntegerToBytecode(testMethodByteCode, var.getAfterPc());

	CtClass variableTester = ClassPool.getDefault().get(
			"ch.unibe.scg.nullSpy.runtimeSupporter.VariableTester");
	CtClass str = ClassPool.getDefault().get("java.lang.String");
	CtClass object = ClassPool.getDefault().get("java.lang.Object");

	testMethodByteCode.addInvokestatic(variableTester,
		"testDirectField", CtClass.voidType, new CtClass[] {
			str, str, str, str, str, str, str,
			CtClass.intType, object, CtClass.intType,
			CtClass.intType, CtClass.intType,
			CtClass.intType });

	byte[] byteCode = testMethodByteCode.get();

	return byteCode;
}
\end{Java}

\coderef{bytecodeCreation} is a code snippet from class \code{VariableTester}\textsuperscript{\ref{package1}} which NullSpy adds to the project after the bytecode modification. This snippet creates the static method invocation that tests whether a field is null. The header of that method is presented in \coderef{checkFieldMethodHeader}.

\begin{Java}[caption={Check field method header.}, label={code:checkFieldMethodHeader}, firstnumber=31]
public static void testDirectField(
	String classNameInWhichVarIsAccessed,
	String behaviorName,
	String behaviorSignature, 
	String varID, String varName, String varType, 
	String varDeclaringClassName,
	int isStatic, 
	Object varValue, 
	int varLineNr, 
	int startPc, int storePc, int afterPc
	) {...}
\end{Java}

Now we will go through the code snippet shown in \coderef{bytecodeCreation} and explain it. The method header of the behavior \code{VariableTester.testDirectField(...)} shown in \coderef{checkFieldMethodHeader} takes seven strings, one boolean, one object and four integers as parameter. The snippet \coderef{bytecodeCreation} reproduces those parameters. 

From line 4 to 17 the instruction \textit{``addLdc''} is used to add strings to the bytecode. For adding a boolean we used the integers \textit{``1''} and \textit{``0''} to represent the boolean value \textit{true} respectively \textit{false}. Lines 20 to 24 adds an integer to the bytecode sequence. 

The Object, in our case a field, is added by the method \code{addAload(...)} at line 26 and the method \code{addGetfield(...)} at lines 27 and 28. In our synthetic example shown in \coderef{fieldExample} we saw that how a field is assigned a value at line 11. The bytecode of this example is \textit{``aload\_0'', \textbar\dots\textbar, ``putfield''}. Even if we don't write the keyword \code{this} in front of the field \code{b}, the bytecode will still be the same. The example was about the field assignment, but if we only want to load a field the bytecode looks like \textit{``aload\_0'', ``getfield''}. Back to our bytecode creation example \coderef{bytecodeCreation}, lines 27 and 28 are exactly adding those instructions to the bytecode. We take the variable itself as parameter to evaluate its value in the check-method.

Important integers like the line number and pcs are added to the bytecode sequence from line 30 to 33. Finally all classes that the check-method takes as parameter are prepared at lines 35 to 38 and the instruction \textit{``invokestatic''} at line 40 is added to the bytecode. If we add a method invocation to the bytecode we have to specify what kind of parameter the invocation takes. For this reason we prepared the classes from line 35 to 38.

With the classes \textit{CodeAttribute} and \textit{CodeIterator} from the Javassist API we can enter the bytecode sequence we created into existing ones. CodeAttribute represents the bytecode of a behavior and with CodeIterator we can iterate through that bytecode. We obtain a CodeIterator object from the CodeAttribute. So we first move the CodeIterator to the position (pc) in the bytecode where we want to enter our bytecode with \code{codeIterator.move(pc)} and than enter our sequence with \code{codeIterator.insert(ourByteCode)}.

There were again some challenges we had to get over, like getting the right data after an instrumentation or inserting the additional bytecode at the right position in the existing bytecode sequence. In (\subsecref{bytecodeAdaptationDifficulties}) we discuss more about our problems we had.

\end{appendices}

\clearpage
\thispagestyle{empty}
\null\vfill
\begin{center}
''Ich erkl\"are hiermit, dass ich diese Arbeit selbstst\"andig verfasst und  keine  anderen  als  die  angegebenen  Quellen  benutzt  habe.
Alle Stellen, die w\"ortlich oder sinngem\"ass aus Quellen entnommen  wurden,  habe  ich  als  solche  gekennzeichnet.  Mir  ist  bekannt,  dass  andernfalls  der  Senat  gem\"ass  Artikel 36  Absatz 1 Buchstabe
r  des  Gesetzes  vom  5. September 1996  \"uber  die  Universit\"at zum Entzug des auf  Grund dieser Arbeit verliehenen Titels berechtigt ist.â
\end{center}
\vfill
\clearpage

\end{document}
